逃逸分析
==

### 1. 简介

逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针， 从而确定一个变量是放在堆上还是栈上。

规则如下：

- 是否在其他地方（非局部）被引用。只要有可能被引用，那么他一定分配到堆上，否则就是分配到栈上
- 即使没有外部引用，如果对象过大，依然有可能分配到堆上

逃逸分析也是编译器用于决定变量是分配到堆熵还是栈上的一种行为。
**Go语言是在编译阶段确定逃逸的，并不是在运行时**

逃逸分析必要性：

- 堆上的变量会经历GC，如果分配过多会导致垃圾回收压力不断增大
- 申请、分配、回收内存的系统开销增大（相对于栈）
- 动态分配产生一定量的内存碎片

### 2. 判断方法

#### 通过编译器提供的命令 -gcflags

```shell
go build -gcflags '-m -l' main.go
```

参数如下：

- -m打印逃逸分析的优化策略，最多可以用4个-m，但是需要调试的信息量比较大，一般只用一个就可以
- -l禁用函数内联，禁用inline可以更好的观察逃逸情况，减少干扰

#### 通过反编译命令查看

```shell
go tool compile -S main.go

```

### 3. 案例表现

#### 3.1 指针被外部引用

#### 3.2 未确定类型会分配到堆上

#### 3.3 某些场景的泄漏参数可能导致逃逸

### 4.总结

- 静态分配到栈上，一般回比动态分配到堆上性能要好
- 底层分配到堆上还是栈上，实际上对我们来说是透明的，不需要过度关心
- 每个Go版本的逃逸分析都会有所不同
- 处处使用指针传递并不一定是最好的，建议合理使用
- 遇到问题，最好实际使用命令做分析


