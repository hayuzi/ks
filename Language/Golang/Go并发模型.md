Go语言进阶
==

## 1. 协程GMP模型

### 1.1 内核线程与用户线程

#### 调度器
- 用户态线程绑定的到内核态线程的关系有如下三种 1:1、 M:1 、 M:N
- 内核线程由CPU调度，是抢占式的
- 协程可以是协作式也可以设计成抢占式、Go在1.14之后改为了抢占式调度

### 1.2 GMP模型内容

- G（goroutine协程）
- M（thread线程）
- - 线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上
- P（Processor处理器）
- - Processor，它包含了运行 goroutine 的资源，如果线程想运行 goroutine，必须先获取 P
- - P 中还包含了可运行的 G 队列


### 1.3 GMP模型调度机制

#### 全局队列（Global Queue）
- 存放等待运行的 G

#### P 的本地队列
- 同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个
- 新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列

#### P 列表
- 所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个

#### M
- 线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时
- M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列
- M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去

### 1.4 P与M数量问题

#### P的数量
- 由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定
- 这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行

#### M的数量
- go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略
- runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量
- 一个 M 阻塞了，会创建新的 M


### 1.5 调度器设计策略

#### 复用线程优点
- 避免频繁地创建、销毁线程，而是对线程的复用
- work stealing 机制
- - 当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程
- hand off 机制
- - 当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行

#### 利用并行
- GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个 goroutine对应的线程 分布在多个 CPU 上同时运行
- GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行

#### 抢占
- 在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程
- 在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方

#### 全局 G 队列
- 在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G

### 1.6 抢占原理 ( 等待完善 )



## 2. 语法重点

### 2.1 一些概念

#### new 与 make
引言： 对于引用类型的变量，我们不光要声明它，还要为它分配内容空间，否则运行的时候会painc

##### new
- 函数源码   func new(Type) *Type
- 它只接受一个参数，这个参数是一个类型，分配好内存后，返回一个指向该类型内存地址的指针。
- 同时请注意它同时把分配的内存置为零，也就是类型的零值
- new，返回的永远是类型的指针，指向分配类型的内存地址

##### make
- make也是用于内存分配的，但是和new不同，它只用于chan、map以及切片的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了
- 因为这三种类型是引用类型，所以必须得初始化，但是不是置为零值，这个和new是不一样的

##### new和make区别
- 所以从这里可以看的很明白了，二者都是内存的分配（堆上），但是make只用于slice、map以及channel的初始化（非零值）；
- 而new用于类型的内存分配，并且内存置为零。所以在我们编写程序的时候，就可以根据自己的需要很好的选择了。
- make返回的还是这三个引用类型本身；而new返回的是指向类型的指针。


### 2.2 性能优化(等待完善)


## 3. goroutine和channel

### 3.1 goroutine

#### 语法与使用
- 使用go关键字来创建一个新的 goroutine
- main函数中执行的是主goroutine

#### goroutine泄漏
- 两个比较慢的goroutine因使用无缓冲通道而卡住。这种情况叫做goroutine泄漏。
- 泄漏的goroutine不会自动回收，所以务必确保goroutine在不需要的时候可以自动结束

#### groutine与线程

##### 线程栈与协程栈
- 每个OS（操作系统）线程都有一个固定大小的栈内存（通常为2MB），栈内存区域用于保存在其他函数调用期间那些正在执行或临时暂停的函数中的局部变量
- 一个goroutine生命周期开始时只有一个很小的栈，典型情况下为2KB，与OS线程类似，goroutine栈内存也用于存放那些正在执行或者临时暂停的函数中的局部变量
- 但是与OS线程不同的是，goroutine的栈不是固定大小的，可以按需增大或者缩小，最大限制可以达到1GB

##### OS线程调度
- OS线程由OS内核来调度。每隔几毫秒，一个硬件时钟中断发送到CPU，CPU调用一个叫做调度器的内核函数。
- 这个函数暂停当前运行的线程、把它的寄存器信息保存到内存、查看线程列表并决定接下来运行哪一个线程，再从内存恢复线程的注册表信息，最后执行选中的线程
- 线程的控制权转移需要一个完整的上下文切换（contex switch）：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构

##### goutoutine调度
- Go运行时包含一个自己的调度器，这个调度器使用一个称为 m:n的调度技术（复用/调度m个goroutine到n个OS线程）
- 与OS调度器不同的是，Go调度器，不是由硬件时钟触发，而是由特定的Go 语言结构来触发的
- 当一个goroutine调用休眠函数、通道阻塞、或者对互斥量操作时，调度器就会将这个goroutine设置为休眠模式，并运行其他goroutine直到前一个可以重唤醒为止
- 因为不需要切换到内核语境，所以调用一个goroutine比调度一个线程成本低很多

##### GOMAXPROCS
- Go 调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码，默认是是机器上CPU的数量
- 正在休眠或者正在被通道通信阻塞的goroutine不需要占用线程
- 阻塞在I/O和其他系统调用中或者调用非Go语言写的函数的Goroutine需要一个独立的OS线程，但这个线程不计算在GOMAXPROCS内
- 可以使用GOMAXPROCS环境变量或者runtime,GROMAXPROCS函数来显式控制这个参数

##### OS线程标识
- 大部分支持多线程的操作系统和编程语言里，当前线程都有一个独特标识，通常可以取一个整数或者指针
- 这个特性可以让我们轻松构建一个线程的局部存储，他本质上就是一个全局map，以线程的标识作为键，这样每个线程都可以独立而不受干扰地用这个map存储获取值

##### goroutine没有标识
- goroutine不提供可供访问的的标识。以防止线程局部存储被滥用



### 3.2 channel 通道

#### 语法与使用

##### 基础语法
- 通道可以让goroutine之间实现通新
- 每一个通道是一个具体类型的导管，这个叫做通道的元素类型 ，像map一样，通道是一个使用make创建的数据结构的引用
- 使用make函数创建通道 ch:= make(chan int) 
- 同种类型的通道可以使用 == 比较，如果二者是同一通道数据的引用时，比较值为true
- 通道的零值是 nil

#### 通道的操作等

##### 基础操作
- 发送 ch <- x ，接收 x = <-ch， 关闭 close(ch)
- 在通道关闭后，任何后续的发送操作都将会导致应用崩溃
- 当你关闭的通道被读完(就是最后一个发送的值被接收)后，所有后续的接收操作顺畅进行，只是获取到的是零值
- 接收操作有一个方式判定是否是在一个关闭的通道上接收数据 x,ok = <-ch 根据ok判断通道是否关闭并读取完， 另外还可以用range语法循环读取通道数据

##### 单向通道
- 这是通道作为函数形参时候的一个限制，接收单向通道不允许发送，发送单向通道不允许接收
- 关闭一个只允许接收的通道在编译时候会报错
- 在赋值操作中双向通道转换为单向通道是允许的，反之不行

##### 无缓冲通道
- make直接创建不带第二个参数创建的通道
- 无缓冲通道进行通信导致发送和接收goroutine同步化。因此无缓冲通道也称同步通道
- 发送goroutine发送后阻塞，等待接收goroutine接收后才能再次被唤醒

##### 缓冲通道
- make函数创建时候接收第二个参数，表示通道容量的整数，如果容量是0，表示无缓冲通道
- 缓冲通道先进先出，满了阻塞发送方，空了阻塞接收方
- 通过cap函数来获取通道缓冲区的容量， len获取当前通道内的元素个数

##### 线程安全的计数器
- sync.WaitGroup，有三个操作 wg.Add() 以及 wg.Done() 还有 wg.Wait()
- Add必须在goroutine开启之前操作
- 而Done在一般在goroutine函数的开始使用defer方式调用，保证错误的情况下依然可以执行
- Wait操作收集等待goroutine执行完成


### 3.3 select多路复用

#### 语法与使用

##### select case语法结构
- 每一个情况指定一次通信（在一些通道上进行发送或者接收操作）和关联一段代码块
- select一直等待，直到一次通信来告知有一些情况可以执行，它进行这次通信并执行对应语句；其他得到通信将不会发生
- 如果多个情况同时满足，select会随机选择一个，这样可以保证每一个通道有相同机会被选中

##### nil通道的作用
- 在nil通道上发送和接收将永远阻塞，对于select语句中的情况，如果其通道是nil，它将永远不会被选择

##### 使用技巧
- select可以用来实现非阻塞通信
- 可以通过关闭某个通道来实现广播机制，实现取消机制，并安全终止正在执行的goroutine
- 测试中的技巧： 在取消事件到来的时候main函数没有返回，执行一个panic调用，运行时将转储存程序中所有goroutine栈，如果主gouroutine是最后一个，它需要自己清理



### 3.4 共享变量实现并发

#### 并发与竞态

##### 并发安全
- 某个方法或者类型等在并发调用的时候仍然能正确工作，那么它就是并发安全的（无其他额外同步机制时）
- 一般并发访问要维护一个更高层的互斥不变量

##### 竞态
- 竞态指多个goroutine按照某些交错顺序执行程序时无法给出正确结果的情况

#### 互斥锁 sync.Mutex

监控模式
- 函数、互斥锁、变量的组合方式称为监控模式
- 扩展: 可重入与不可重入锁
- - 不可重入锁：即无法对一个已经上锁的互斥量再上锁，如果有操作，则会死锁阻塞
- - 可重入锁：可重入锁也叫递归锁，已经上锁的互斥量可以再次上锁，依次增加上锁计数，释放则依次减少锁计数直至完全释放
- Go语言的的互斥量是不可以再入的

##### 实现原理（等待扩充）
- Lock方法 CAS（CompareAndSwap查找和替换）获取锁，获取失败进入自旋抢锁，直到抢到锁后返回
- 饥饿模式与正常模式： 两种模式的切换防止某些Goroutine获取不到锁无限等待

#### 读写互斥锁 sync.RWMutex

- 共享锁
- - mu.RLock() 与 mu.RUnlock() 可以加解共享锁
- 互斥锁
- - mu.Lock() 与 mu.Unlock() 可以加解互斥锁
- 多读单写锁
- - 竞争不激烈的时候，它比普通的互斥锁慢

#### 内存同步
- 通道通信或者互斥锁这样同步原语都会导致处理器把积累的写操作刷回内存并提交，如此来保证数据在goroutine之间的可见性

#### 延迟初始化 sync.Once
- Do() 方法以初始化函数作为它的参数
- 每次调用Do时就锁定互斥量并检查 once内部的布尔变量，第一次调用时候会调用 初始化函数，并把once内置布尔变量设置为真

#### 竞态检测器
- race detector
- 简单的把 -race命令行参数添加到go bulid、go run、go test 命令就可以使用该功能

#### 并发非阻塞缓存
并发、重复抑制、非阻塞缓存的实现方式

两种方式构建并发结构
- 通信顺序进程
- 共享变量并上锁


## 4. context

### 4.1 基本概念

#### 什么是 context
- Go 1.7 标准库引入 context，中文译作“上下文”，准确说它是 goroutine 的上下文，包含 goroutine 的运行状态、环境、现场等信息
- context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。
- 随着 context 包的引入，标准库中很多接口因此加上了 context 参数，例如 database/sql 包。context 几乎成为了并发控制和超时控制的标准做法

#### 作用
- context.Context 类型的值可以协调多个 groutine 中的代码执行“取消”操作，并且可以存储键值对。最重要的是它是并发安全的。
- 与它协作的 API 都可以由外部控制执行“取消”操作，例如：取消一个 HTTP 请求的执行
- 一句话：context 用来解决 goroutine 之间退出通知、元数据传递的功能。



## 5. 并发模型介绍

### 5.1 基本模型类型
#### 5.1.1 共享内存
- 通过线程天然的共享内存实现，由程序对读写做同步控制（有锁或无锁）

#### 5.1.2 进程通信
- 多个进程通过进程间通讯或者内存映射实现数据的同步


### 5.2 Actors模型

#### 5.2.1 组成角色

##### Actors
- Actors： 一个actor是一个基本的计算单元，通常actor会接收消息，然后基于消息来做某些计算
- 每个actor是完全隔离的，他们不会共享内存；同时，actor也会维护自身的私有状态，并且不会直接被其他的actor修改。
- 在Actor并发模型中，一切事物都是actor，为了发送消息给actor，我们需要知道某个actor的地址。

##### Mailboxs
- 尽管可以一次运行多个actor，但actor会顺序的处理收到的消息
- 如果你同时发送三个消息给同一个actor，它将会一次处理一个
- 为了让这三个消息被并行的处理，需要创建三个actor，并将这个消息发送给他们
- 消息是被异步地发送给actor，如果一个actor正在处理某个消息，这个时候给它发送了其他消息，需要将这些消息存储到某个地方
- 邮箱(mailbox)正是存储消息的地方，注意，这里的mailbox是具名的，可以理解为mailbox绑定到actor上的，跟CSP中的channel是匿名的不同

#### 5.2.2 执行原理

##### Actors具体功能
当一个actor接收到消息后，它可能做三件事:
- 创建更多的actor
- 发送消息给其他的actor
- 决定收到下一条消息应该做什么

##### 容错
- 我们构建一个可以自愈(self heal)的系统，当一个actor进入到异常状态，发生了crash，监控的actor能够去负责处理，然后回到一个一致的状态

##### 分布式
- 如果我们要发送一个消息跟actor，并不需要关心这个actor是本地的还是其他节点上的


### 5.2 CSP模型

#### 组成角色
- 管道 channel
- -  CSP(Communicating Sequential Process)模型提供一种多个进程公用的“管道(channel)”, 这个channel中存放的是一个个”任务”.
- 进程或线程/协程等
- -  目前正流行的go语言中的goroutine就是参考的CSP模型
- -  原始的CSP中channel里的任务都是立即执行的，而go语言为其增加了一个缓存，

即任务可以先暂存起来，等待执行进程准备好了再逐个按顺序执行

### 5.3 CSP和Actor的区别

- CSP进程通常是同步的(即任务被推送进Channel就立即执行，如果任务执行的线程正忙，则发送者就暂时无法推送新任务)，Go语言有缓冲
- Actor进程通常是异步的(消息传递给Actor后并不一定马上执行)
- CSP中的Channel通常是匿名的, 即任务放进Channel之后你并不需要知道是哪个Channel在执行任务，而Actor是有“身份”的，你可以明确的知道哪个Actor在执行任务
- 在CSP中，我们只能通过Channel在任务间传递消息, 在Actor中我们可以直接从一个Actor往另一个Actor传输数据。
- CSP中消息的交互是同步的，Actor中支持异步的消息交互
