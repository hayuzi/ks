部分源码分析
==

## 1. Go并发哲学
- Go依赖于称为CSP（Communicating Sequential Processes）的并发模型，通过Channel实现这种同步模式。
- Go并发的核心哲学是不要通过共享内存进行通信; 相反，通过沟通分享内存

## 2. channel原理

### 2.1 概览

- channel 的经典思想了，不要通过共享内存来通信，而是通过通信来实现内存共享
- 可以参考 https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&mid=2247485680&idx=1&sn=84992a43a2a2dcbc6cb015729322e7aa&chksm=f9041dadce7394bb3aebbd8f021782cce1fad3e2fba76fc57ebc95c3ede68b30dd0bfed1106d&scene=132#wechat_redirect
- 在runtime.chan 文件中可以看到源码
- 本质上 channel 在设计上就是环形队列。其包含发送方队列、接收方队列，加上互斥锁 mutex 等结构。
- hchan 结构体是 channel 在运行时的具体表现形式

### 2.2 hchan结构体设计
- qcount ： 队列中的元素总数量
- dataqsiz ： 循环队列的长度
- buf ： 指向长度为 dataqsiz 的底层数组，仅有当 channel 为缓冲型的才有意义
- - 缓冲区是一个有锁的环形队列，采用FIFO的方式存入与读取队列数据
- elemsize ： 能够接受和发送的元素大小
- closed ： 是否关闭
- elemtype ： 能够接受和发送的元素类型
- sendx ： 已发送元素在循环队列中的索引位置
- recvx ： 已接收元素在循环队列中的索引位置
- recvq ： 接受者的 sudog 等待队列（缓冲区不足时阻塞等待的 goroutine）
- sendq ： 发送者的 sudog 等待队列
- - 其类型为 runtime.waitq 的双向链表结构
- - 且无论是 first 属性又或是 last，其类型都为 runtime.sudog 结构体
- - sudog 是 Go 语言中用于存放协程状态为阻塞的 goroutine 的双向链表抽象，你可以直接理解为一个正在等待的 goroutine 就可以了

### 2.3 channel操作

#### channel 创建
- 创建 channel 的逻辑主要分为三大块
- 当前 channel 不存在缓冲区，也就是元素大小为 0 的情况下，就会调用 mallocgc 方法分配一段连续的内存空间
- 当前 channel 存储的类型存在指针引用，就会连同 hchan 和底层数组同时分配一段连续的内存空间
- 通用情况，默认分配相匹配的连续内存空间
- 需要注意到一块特殊点，那就是 channel 的创建都是调用的 mallocgc 方法，也就是 channel 都是创建在堆上的。
- 因此 channel 是会被 GC 回收的，自然也不总是需要 close 方法来进行显式关闭了

#### 2.3.1 发送数据
源码位置：其在编译器翻译后对应 runtime.chansend1 方法

##### 发送数据前置
- 一开始chansend 方法在会先判断当前的 channel 是否为 nil。
- 若为 nil，在逻辑上来讲就是向 nil channel 发送数据，就会调用 gopark 方法使得当前 Goroutine 休眠，进而出现死锁崩溃，
- 表象就是出现 panic 事件来快速失败
- 紧接着会对非阻塞的 channel 进行一个上限判断，看看是否快速失败
- 若非阻塞且未关闭，同时底层数据 dataqsiz 大小为 0（缓冲区无元素），则会返回失败。
- 若是 qcount 与 dataqsiz 大小相同（缓冲区已满）时，则会返回失败

##### 上互斥锁
- 在完成了 channel 的前置判断后，即将在进入发送数据的处理前，channel 会进行上锁

##### 直接发送数据
- 在正式开始发送前，加锁之后，会对 channel 进行一次状态判断（是否关闭）
- 当前 channel 有正在阻塞等待的接收方，那么只需要直接发送就可以了

##### 缓冲发送数据
- 判断 channel 缓冲区中是否还有空间
- 会对缓冲区进行判定（qcount 和 dataqsiz 字段），以此识别缓冲区的剩余空间
- 有空间：则数据入环形队列，更新sendx以及队列总数量，最后解锁互斥锁，返回结果
- 若没有走进缓冲区处理的逻辑，则会判断当前是否阻塞 channel，若为非阻塞，将会解锁并直接返回失败

##### 阻塞发送
- 挂起当前 goroutine
- 在当前 goroutine 被挂起后，其将会在 channel 能够发送数据后被唤醒

#### 2.3.2 接收数据

##### 接收前置处理：
- 一开始时 chanrecv 方法会判断其是否为 nil channel
- 若 channel 是 nil channel，且为阻塞接收则调用 gopark 方法挂起当前 goroutine
- 若 channel 是非阻塞模式，则直接返回
- 而接下来对于非阻塞模式的 channel 会进行快速失败检查，检测 channel 是否已经准备好接收
- 无缓冲区：循环队列为 0 及等待队列 sendq 内没有 goroutine 正在等待
- 有缓冲区：缓冲区数组为空
- 随后会对 channel 的 closed 状态进行判断
- 未关闭状态。再确定接收失败，返回
- 但若是 channel 已经关闭且不存在缓存数据了，则会清理 ep 指针中的数据并返回

##### 直接接收
- 当发现 channel 上有正在阻塞等待的发送方时，则直接进行接收 
  
##### 缓冲接收
- 当发现 channel 的缓冲区中有元素时：
- 从环形队列接收数据，并更改数据相关计数，清理内存数据

##### 阻塞接收
- 当发现 channel 上既没有待发送的 goroutine，缓冲区也没有数据时。将会进入到最后一个阶段阻塞接收
- 阻塞等待唤醒，最终恢复执行并返回数据

#### 2.3.3 关闭 chan

##### 概览
其对应的编译器翻译方法为 closechan 方法

##### 前置处理
基本检查和关闭标志设置，保证 channel 不为 nil 和未关闭，保证边界。

##### 释放接收方
- 在完成了异常边界判断和标志设置后，会将接受者的 sudog 等待队列（recvq）加入到待清除队列 glist 中
- 所取出并加入的 goroutine 状态需要均为_Gwaiting，以保证后续的新一轮调度。

##### 释放发送方
同样，与释放接收方一样。会将发送方也加入到到待清除队列 glist 中

##### 协程调度
- 将所有 glist 中的 goroutine 状态从 _Gwaiting 设置为 _Grunnable 状态，等待调度器的调度
- 后续所有的 goroutine 允许被重新调度后。若原本还在被动阻塞的发送方或接收方，将重获自由，后续该干嘛就去干嘛了，再跑回其所属的应用流程





## 3. sync.WaitGroup原理
- 数据结构包含：计数器，等待者个数，信号量
- add以及Done的语法，基于原子操作（sync/atomic包）实现并发的控制
- wait通过阻塞当前goroutine等待其他goroutine的执行，完成之后，会重新唤醒当前的goroutine



## 4. sync.Mutex

### 4.1 两种模式
#### 正常模式（竞争模式）
- 被唤醒的等待者，并不能代表它已经拥有了这个mutex锁，它需要与新到达的goutine争夺mutex锁

#### 饥饿模式（队列模式）
- mutex锁会直接由解锁的goroutine交给队列头部的等待者，这个需要按照队列先进先出

### 4.2 数据结构

#### 包含一个 状态值
- state：将一个32位整数拆分为： 当前阻塞的goroutine数(29位)
- 饥饿状态(1位，0为正常模式；1为饥饿模式)
- 唤醒状态(1位，0未唤醒；1已唤醒)
- 锁状态(1位，0可用；1占用)

#### 包含一个 信号量
- 正常信号量

### 4.3 相关操作

#### 4.3.1 Lock （此处流程已经简化）
- 第一步：判断state状态是否为0，如果为0，证明没有协程持有锁，那么就很简单了，直接获取到锁，将 mutexLocked（为1）赋值到state就可以了
- 第二步：判断 如果不是饥饿模式并且是否能够执行自旋函数（判断自旋次数），如果可以则进入自旋逻辑区间
- 第三步：自旋逻辑区前置流程：未被唤醒 && 排队goroutine数量不为0 && 使用CAS设置状态为已唤醒时候，设置激活状态为 true。然后进入自旋。
- 第三步续：进入自旋后，当前goroutine并不挂起，仍然在占用CPU资源，所以重试一定次数后，不会再进入自旋逻辑
- 第四步：如果不能执行自旋，则增加等待goroutine数量，并转换到饥饿模式进行排队阻塞
- 第五步：如果当前goroutine被唤醒，需要在两种情况下重设标志，后面如果成功获取到锁，后续代码判断是否从饥饿模式恢复为正常模式

#### 4.3.2 UnLock
- 第一步：标识解锁，并验证状态是否符合
- 后续：判断是否处于正常模式，如果无等待的协程，则直接退出，如果有等待的，则通过信号量让出来唤醒某一个协程
- 如果是饥饿模式：则将所有权移交给下一个等待的goroutine



## 5. sync.RWMutex

### 5.1 信号量
- 读写锁与互斥锁都基于信号量问题（参考操作系统原理中的实现），另外还需要了解锁的自旋
- 申请 acquire（也称为 wait、 decrement 或者 P操作）
- 释放 release（也称为 signal、increment或者 V操作）

### 5.2 数据结构
- 包含一个 互斥锁 w Mutex ，这个锁的目的就是控制多个写入操作的并发执行
- writerSem 写入操作的信号量
- readerSem 是读操作的信号量
- readerCount 是当前读操作的个数
- readerWait 当前写入操作需要等待读操作解锁的个数

### 5.3 相关的操作

#### 5.3.1 RLock
- 获取读锁
- 原子更改，读计数 readerCount + 1， 如果结果小于0，表明有写锁占用，调用 runtime_Semacquire(&readSem)进行读信号量的等待（等待信号量 > 0）

#### 5.3.2 Lock
- 获取写锁
- 先获取互斥锁，保证只有一个写操作可以获取到写锁
- 后原子更改, 写计数 readerCount - rwmutexMaxReaders。（每个协程读取锁就+1，一直都是正数，现在有写锁过来，瞬间减为很大的负数，如此，所有读操作都阻塞等待）
- 再后原子更改，并且将readerWait加上原来的readerCount（未减少的）（表示需要等待readerCount这么多个读锁进行解锁）
- 如果 readerCount+最大读数量不等于0（原来有协程已经获取到了读锁）且 readerWait不等于0，则 runtime_Semacquire(&writerSem)进行写信号量等待

#### 5.3.3 RUnLock
- 释放读锁
- 原子操作将之前+1的readerCount-1
- 如果-1之后再+1==0是啥情况？没错就是我们常见的，新手程序员，没有获取读锁就想去释放读锁，于是异常了。当然+1之后刚好是rwmutexMaxReaders，就证获取了写锁而去释放了读锁，导致异常。
- 剩下的就是r（=readerCount+1）还是<0的情况，那么证明确实有协程正在想要获取写锁，那么就需要操作我们前面看到的readerWait，
- 当readerWait减到0的时候就证明没有人正在持有写锁了，就通过信号量writerSem的变化告知刚才等待的协程（想要获取写锁的协程）：你可以进行获取了。

#### 5.5.4 UnLock
- 释放写锁
- 写锁释放需要恢复 readerCount，上锁时候减去的那个很大的数要加回来
- 当然加完之后如果>=rwmutexMaxReaders本身，那么还是新手程序员的问题，当没有获取写锁的时候就开始想着释放写锁了
- 然后for循环就是通知所有在我们RLock方法中看到的，当有因为持有写锁所以等待的那些协程，通过信号量readerSem告诉他们可以动了
- 最后需要释放互斥锁，让别的协程也可以开始抢写锁了

#### 5.5.5 竞态分析
- 这几个方法中有竞态分析的采集代码，有兴趣可以了解一下