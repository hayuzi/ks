搜索引擎-Elasticsearch
==

## 1. 文档及基础使用
基础使用以及操作请参考官方文档（需要选择对应的版本进行学习，不同版本有不兼容问题）

主要内容大概有如下几点：
- 索引/版本/搜索/分页
- Mapping
- 解析器
- - 自定义解析器应用
- - ik中文分词插件 / 拼音搜索
 

## 2. 设计原理

### 2.1 索引组织原理

#### 2.1.1 倒排索引

##### Term Dictionary
Posting List
- 包含每个符合某个term的文档ID
- 还包括 文档数量、此条在每个文档中出现的次数、出现的位置、每个文档的长度、所有文档的平均长度等

##### Term Index
作用与原理
- 而 Lucene 在 term dictionary 的基础上添加了 term index 来加速检索，term index 以树的形式缓存在内存中。
- 从 term index 查到对应的 term dictionary 的 block 位置之后，再去磁盘上找 term，大大减少了磁盘的 random access 次数

使用 FST（有限状态机）
- 实际上，Lucene 内部的 Term Index 是用的「变种的」trie前缀树，即 FST
- FST 比 trie树好在哪？trie树只共享了前缀，而 FST 既共享前缀也共享后缀，更加的节省空间。

##### 查询流程
索引数据提取
- Lucene 的tip文件即为 Term Index 结构，tim文件即为 Term Dictionary 结构。
- tip中存储的就是多个FST，FST中存储的是<单词前缀，以该前缀开头的所有Term的压缩块在磁盘中的位置>。
- 即为前文提到的从 term index 查到对应的 term dictionary 的 block 位置之后，再去磁盘上找 term，大大减少了磁盘的 random access 次数。

联合索引数据合并
- 使用 skip list 合并（跳表构建可压缩）
- 使用 bitset 合并

参考:
- https://blog.csdn.net/qq_34820803/article/details/104798716


#### BKD树(待完善)


### 2.2 文件系统缓存 、 读取 / 写入/ 删除 流程

### 2.3 写索引流程

#### 分片路由功能
- 根据公式计算分片 shard= hash(routing) % number_of_parimary_shards
- Routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。

#### 处理流程
- 写请求发送到协调节点-->协调节点计算路由确定分片-->转发请求到该分片的主分片节点上
- -->主分片存储落盘-->并发复制到副本分片(所有副本分片报告成功则主分片节点向协调节点报告成功) --> 返回节点给客户端

### 2.4 存储原理

#### 分段存储原理
- 索引文档以段的形式存储在磁盘上
- 何为段？ 索引文件拆分为多个子文件，则每个子文件叫做段，每个段本身都是一个倒排索引，并且段具有不变性，一旦索引数据被写入硬盘，就不可再修改
- 新增操作，新增段；删除操作，新增 .del的段，标记删除；更新操作，需要新增段以及.del的段

#### 段不变性优缺点
- 优点：一、不需要锁；二、索引不变可以常驻内存；三、其他缓存在索引生命周期内始终有效；四、单个大的倒排索引允许数据被压缩
- 缺点：一、只增不减对删除更新数据来说会造成空间浪费；二、段太多消耗文件句柄、三、查询结果过滤删除数据增加负担

#### 分段处理操作
- 合并策略：较小的分段会定期合并为较大的分段，合并后的分段会被标记删除。（然后这些分段会不时地写入磁盘）
- 刷新（refresh）：ES重新打开索引，让新建的文档可用于搜索。写入和打开一个新段的轻量过程叫做Refresh（内存刷新到文件缓存系统）
- 冲刷（flush）：将索引数据从内存写入磁盘
- 存储和存储限流：ES调节每秒写入字节数量，来限制合并给对于IO系统的影响
- 触发flush的条件（内存缓冲区已满、自上一次冲刷后超过了一定的时间、事务日志达到了一定的阈值）

#### 延迟写策略
- 数据先记入内存（ES的JVM内存），在达到默认时间（1s）或者内存达到一定量时候，会触发一次刷新，将内存中的数据生成到一个新的段上并缓存到文件缓存系统上，然后再刷入到磁盘中并生成提交点
- 近实时性： 数据在JVM内存的时候不是段形式存储的，因此不能提供检索功能，但是刷新到文件系统缓存（操作系统内存）之后，即可以检索了
- translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失 5 秒钟的数据。
- 但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多。

##### 事务日志： 写入步骤
1. 写操作写入内存并追加一份数据到事务日志
2. 刷新时间或者内存中数据达到一定量，触发refresh操作，将内存数据转存到文件系统缓存中
3. 当数据日志大小超过 512M（(由 index.translog.flush_threshold_size控制，默认512mb)）或者时间超过30分后，会触发一次Flush
4. flush：文件系统缓存数据通过Fsync 刷入到磁盘中，生成提交点，日志文件被删除，创建一个空的新日志


## 3. 集群原理

### 3.1 集群管理机制

#### 发现机制
- Zen Discovery发现模块，使用单播方式连到集群
- 当一个节点联系到单播列表中的成员时，它就会得到整个集群所有节点的状态，然后它会联系 Master 节点，并加入集群。
- 这意味着单播列表不需要包含集群中的所有节点， 它只是需要足够的节点，当一个新节点联系上其中一个并且说上话就可以了。
- 如果你使用 Master 候选节点作为单播列表，你只要列出三个就可以了。这个配置在 elasticsearch.yml 文件中：

#### 选举机制
- 支持任意数目的集群（1-N），所以不能向Zookeeper那样限制节点必须是奇数
- 集群节点遵循同样规则，只要得到的信息是对等的，那么选举出来的主节点肯定是一致的。
- 脑裂问题解决：大多数解决方案就是设置一个 Quorum 值，要求可用节点必须大于 Quorum（一般是超过半数节点），才能对外提供服务
- Quorum的配置项 ：discovery.zen.minimum_master_nodes

#### 脑裂问题

##### 产生原因
- 网络问题，集群网络延迟导致一些节点访问不到Master，认为Master挂掉了从而选举出新的Master，并对Mastar上的分片和副本标红，分配新的主分片
- 节点负载：主节点的角色既为 Master 又为 Data，访问量较大时可能会导致 ES 停止响应（假死状态）造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。
- 内存回收：主节点的角色既为 Master 又为 Data，当 Data 节点上的 ES 进程占用的内存较大，引发 JVM 的大规模内存回收，造成 ES 进程失去响应。

##### 解决方法
- 适当调大响应时间，减少误判。通过参数 discovery.zen.ping_timeout 设置节点状态的响应时间，默认为 3s，可以适当调大
- 选举触发。我们需要在候选集群中的节点的配置文件中设置参数 discovery.zen.munimum_master_nodes 的值。（默认为1，建议设置为 (n/2)+1）
- 角色分离。即上面我们提到的候选主节点和数据节点进行角色分离，这样可以减轻主节点的负担，防止主节点的假死状态发生，减少对主节点“已死”的误判。

### 3.2 节点角色

#### 数据节点
- 数据节点负责数据的存储和相关的操作，例如对数据进行增、删、改、查和聚合等操作，所以数据节点（Data 节点）对机器配置要求比较高，对 CPU、内存和 I/O 的消耗很大。

#### 候选主节点
- 候选主节点可以被选举为主节点（Master 节点），集群中只有候选主节点才有选举权和被选举权，其他节点不参与选举的工作。
- 主节点负责创建索引、删除索引、跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点、追踪集群中节点的状态等，稳定的主节点对集群的健康是非常重要的。

#### 协调节点
- 用户的请求可以发往任何一个节点，并由该节点负责分发请求、收集结果等操作，而不需要主节点转发
- 这种节点可称之为协调节点，协调节点是不需要指定和配置的，集群中的任何节点都可以充当协调节点的角色。

#### 其他节点类型


### 3.3 分片与副本

#### 分片管理
- 数据分片可以分散整体数据到不同的数据块上，实现分布式存储管理。ES通过分片使得索引在规模上和性能上都得到提升
- 每一个分片都是Lucene中的一个索引文件，每个分片必须有一个主分片和0到多个副本
- ES默认分片一个索引创建5个，并为每个分片创建一个副本。（都可配置）

#### 分片副本
- 副本（replicas）就是对分片的copy，当主分片异常时候，副本可以提供数据的查询等操作
- 当节点数量足够，副本分片和主分片不会 在同一个节点上
- 对文档的新建、索引和删除请求都是写操作，必须在主分片上面完成之后才能被复制到相关的副本分片。
- ES 为了提高写入的能力这个过程是并发写的，同时为了解决并发写的过程中数据冲突的问题，ES 通过乐观锁的方式控制，每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。
- 所有副本写成功才返回：一旦所有的副本分片都报告写成功才会向协调节点报告成功，协调节点向客户端报告成功。

## 4. 性能优化

### 4.1 文件系统缓存 / 内存空间 / 磁盘空间 / 数量
- 推荐 64G内存，JVM内存与文件系统缓存各一半

### 4.2 数据预热
- 做一个专门的缓存预热子系统，对热数据每隔一段时间前访问一下，让数据进入 filesystem cache 里面去

### 4.2 冷热分离

### 4.4 数据异构精简
- 目的：保证数据尽量放置到文件系统缓存，避免访问磁盘
- 选择顺序ID，提高压缩比
- 尽量只存储需要索引的字段，并且选择适当的解析器，控制索引大小
- 如果有可能、指定routing值，可以快速定位

### 4.5 分页优化等
- 避免深度分页查询
- 遍历考虑使用 Scroll方式查询

### 4.6 机器硬件提升
- 存储设备
- - 使用SSD等
- 内存空间
- - 64G内存，JVM和系统各占32

### 4.7 内部索引优化
- ES/Lucene的索引结构已经做了优化（ Term Dictionary、Term index 以及 FST），磁盘上的倒排表也采用了压缩技术减少存储所占用的空间


## 5. 数据同步

### 版本顺序，保证最新
- 根据时间序列，确定更新顺序以及是否需要丢弃等

### MQ方式同步

### Canal 监听binlog日志
