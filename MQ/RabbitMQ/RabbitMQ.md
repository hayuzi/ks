RabbitMQ
==

## 工作原理

### AMQP协议
#### AMQP 是什么
AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。
RabbitMQ 便是基于AMQP协议设计的消息队列中间件

#### AMQP模型工作过程
发布者（Publisher）发布消息（Message），经由交换机（Exchange）。
交换机根据路由规则将收到的消息分发给与该交换机绑定的队列（Queue）。
最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。

### 工作原理概述

#### RabbitMQ的基本术语
- Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。
- Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。
- Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。
- Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。
- Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。
#### Exchange说明
- 常用的交换器主要分为一下三种：
- fanout：如果交换器收到消息，将会广播到所有绑定的队列上
- direct：如果路由键完全匹配，消息就被投递到相应的队列
- topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符

#### 传输通道
- 由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。
- RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制

### 工作模式

#### 1、simple（简单队列）
- 消息产生消息，将消息直接放入队列

#### 1、Work queues（工作队列）
- work queues与入门程序相比，多了一个消费端，两个消费端共同消费同一个队列中的消息。
- 应用场景：对于 任务过重或任务较多情况使用工作队列可以提高任务处理的速度
- work queues不用定义交换机，实质上work queues会将队列绑定到默认的交换机

#### 2、Publish/Subscribe（发布订阅模式）
- 1、每个消费者监听自己的队列。
- 2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息
- 声明Exchange_fanout_inform交换机。声明两个队列并且绑定到此交换机，绑定时不需要指定routingkey，发送消息时不需要指定routingkey

#### 3、Routing（路由模式）
- 1、每个消费者监听自己的队列，并且设置routingkey。
- 2、生产者将消息发给交换机，由交换机根据routingkey来转发消息到指定的队列

#### 4、Topics
- 通配符模式
- 1、每个消费者监听自己的队列，并且设置带通配符的routingkey。
- 2、生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。

RabbitMQ的topic方式下的消息投递机制，topic下路由的 ‘#’ 与 ‘*’ 各代表什么意思
- "*"号代表任意一个单词
- "#"号代表0个或多个单词

#### 5、Header
- header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。

#### 6、RPC
- RPC即客户端远程调用服务端的方法 ，使用MQ可以实现RPC的异步调用，基于Direct交换机实现


## RabbitMQ 普通集群

### 工作原理

#### 元数据类型
- 队列元数据：队列名称和它的属性
- 交换器元数据：交换器名称和它的属性
- 绑定元数据：一张简单的表格展示了如何将消息路由到队列
- vhost元数据：为vhost内的队列、交换器和绑定提供命名空间和安全属性

#### 信息分布
- 整个集群中 交换器和队列的元数据在所有节点上是一致的，而Queue的完整数据则只会存在于它所创建的那个节点上
- 其他节点只知道这个Queue的元数据信息和指向 Queue的woner node的指针

#### 为何仅元数据同步
- 节省存储空间：每个集群节点都拥有所有Queue的数据完全拷贝，那么空间占用会很严重，消息积压能力会非常弱
- 性能：消息发布需要将消息复制到每个集群节点的话，对于持久化消息、网络和磁盘同步复制的开销都会明显增加

### 客户端连接

#### 直连队列所在节点
- 直接接连的话，消息收发只与 该节点相关

#### 非队列所在节点
- 非直接连接队列所在节点的话，那么这个节点会只是起到一个路由作用，最终消息读写操作还是会转发到队列所在节点上

### 节点类型

#### 磁盘节点
- 将配置信息和元信息存储在磁盘上（单节点系统必须是磁盘节点，否则每次重启RabbitMQ之后所有的系统配置信息都会丢失）
- RabbitMQ要求集群中至少有一个磁盘节点，当节点加入和离开集群时，必须通知磁盘节点
- 总之如果唯一磁盘的磁盘节点崩溃，集群是可以保持运行的，但不能更改任何东西
- 建议设置至少两个的磁盘节点，作为灾备

#### 内存节点
- 将配置信息和元信息存储在内存中。性能是优于磁盘节点的。

### 节点优缺点分析

#### 优点
- 多节点可以分散单台机器的消息存储压力

#### 缺点
- 并不能保证高可用
- 虽然该模式解决一项目组节点压力，但队列节点宕机直接导致该队列无法应用，只能等待重启。

## 镜像队列集群

### 镜像队列结构

#### 关于node节点
- queue有master节点和slave节点。
- 要强调的是，在RabbitMQ中master和slave是针对一个queue而言的，而不是一个node作为所有queue的master，其它node作为slave。
- 一个queue第一次创建的node为它的master节点，其它node为slave节点。

#### 创建队列的属性
- Name: 你配置的Policy名称；
- Pattern: 匹配模式，图片的是匹配testMirror开头的交换机和队列；
- Priority: 优先级；
- Definition
- Definition: 一些模式的定义，RabbitMQ已经列出了以下常见的模式定义。
- ha-mode是指定镜像队列的模式，有效值为all/exactly/nodes。 
- - 其中all表示在集群中所有的节点上进行镜像；
- - exactly表示在指定个数的节点上进行镜像，节点的个数由ha-params指定；
- - nodes表示在指定的节点上进行镜像，节点名称通过ha-params指定。
- ha-sync-mode为指定镜像队列中消息的同步方式，有效值为automatic(自动同步)，manually(手动同步)；
- - 默认是manually，请注意一定要记得设置为automatic(自动同步），否则消息在镜像队列中是不会自动同步的（即普通集群模式），即新节点加入时不会自动同步消息和元数据，只能通过命令手动去同步。

### 工作原理

#### 基础预备

- 镜像队列是基于普通的集群模式的，然后再添加一些策略，所以还是得先配置普通集群，然后才能设置镜像队列。
- 镜像队列存在于多个节点。要实现镜像模式，需要先搭建一个普通集群模式，在这个模式的基础上再配置镜像模式以实现高可用。
- 通过配置，设置每个队列有几个镜像，镜像集群会将多个队列镜像放置在不同的节点上
- 生产者发送的的消息都会同时在镜像队列中同时存储，消费之后，也会从镜像队列删除

#### 镜像队列服务提供方式
- 在镜像队列集群模式中，对某个queue来说，只有master对外提供服务，而其他slave只提供备份服务
- 在master所在节点不可用时，选出一个slave作为新的master继续对外提供服务
- 无论客户端的请求打到master还是slave最终数据都是从master节点获取
- 当请求打到master节点时，master节点直接将消息返回给client，同时master节点会通过GM（Guaranteed Multicast）协议
将queue的最新状态广播到slave节点
- GM保证了广播消息的原子性，即要么都更新要么都不更新
- 当请求打到slave节点时，slave节点需要将请求先重定向到master节点，master节点将将消息返回给client，同时master节点会通过GM协议将queue的最新状态广播到slave节点
- 所以，多个客户端连接不同的镜像队列不会产生同一message被多次接受的情况

#### 处理新增节点

- 如果有新节点加入，RabbitMQ不会同步之前的历史数据，新节点只会复制该节点加入到集群之后新增的消息。
- RabbitMQ集群内部会维护节点的状态是否已经同步，使用rabbitmqctl的synchronised_slave_pids参数，就可以查看状态
- 如果slave_pids和synchronised_slave_pids里面的节点是一致的，那说明全都同步了；如果不一致很容易比较出来哪些还没有同步
- 集群只会在“最老”的slave节点之间选一个出来作为新的master节点。另外对于node节点的重启也是按照新节点来处理的

#### 注意点
- 镜像队列不能作为负载均衡使用，因为每个声明和消息操作都要在所有节点复制一遍
- ha-mode参数和durable declare对exclusive队列都不生效， 因为exclusive队列是连接独占的，当连接断开，队列自动删除。所以实际上这两个参数对exclusive队列没有意义
- 每当一个节点加入或者重新加入(例如从网络分区中恢复回来)镜像队列，之前保存的队列内容会被清空
- 对于镜像队列，客户端basic.publish操作会同步到所有节点；而其他操作则是通过master中转，再由master将操作作用于salve

#### 缺陷分析

- 该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用

### 故障恢复

#### 具体场景

- 可以参看该文章 https://www.pianshen.com/article/5946333299/


## 与其他MQ进行对比

### 维度对比

#### ActiveMQ
- 单机吞吐 比RabbitMQ低
- Java 开发， 主要维护者Mozilla/Spring，项目成熟， 社区不太活跃，目前使用者也少了
- 订阅形式：点对点(p2p)、广播（发布-订阅）
- 支持少量消息堆积、不支持顺序消息、稳定性好
- 支持简单集群模式，比如’主-备’，对高级集群模式支持不好。管理界面一般

#### RabbitMQ
- 单机吞吐 2.6w/s（消息做持久化）
- Erlang 开发， 主要维护者 Apache，项目成熟，社区活跃
- 提供了4种订阅形式：direct, topic ,Headers和fanout。fanout就是广播模式
- 支持少量消息堆积、不支持顺序消息、稳定性好
- 支持简单集群，'复制’模式，对高级集群模式支持不好。管理界面较好

#### RocketMQ
- 单机吞吐 11.6w/s
- Java开发， 主要维护者Alibaba，已经转Apache，项目开源版本不够成熟
- 基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式
- 支持大量堆积、支持顺序消息、稳定性一般
- 常用 多对’Master-Slave’ 模式，开源版本需手动切换Slave变成Master。管理界面一般

#### Kafka
- 如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范
- 单机吞吐 17.3w/s
- Scala/Java开发， 主要维护者 Apache，比较成熟
- 基于topic以及按照topic进行正则匹配的发布订阅模式
- 支持大量堆积、支持顺序消息、稳定性较差
- 天然的‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave。无管理界面

## 实践问题

### 引入队列基本优缺点

#### 优点
- 异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。
- 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。
- 流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。
- 日志处理 - 解决大量日志传输。
- 消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。

#### 缺点

- 系统可用性降低
- 系统复杂度提高
- 一致性问题

### 关联架构知识

#### 高可用设计
- 消息队列的高可用保证
- RabbitMQ可以使用镜像集群来保证高可用、消息需要开启持久化
- 但是可能会牺牲一定的性能
- 这个需要根据业务具体场景来设计使用

#### 消息顺序性保证
- 一、独立队列独立消费
- - 并行度就会成为消息系统的瓶颈（吞吐量不够）
- - 系统异常时流程会阻塞，可用性差
- - 不关注乱序的应用实际大量存在
- - 队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式
- 二、业务中保证顺序
- -  设计业务流程时候尽量将业务设计成可以并行处理
- - 如果实在不行，可以选择前置流程完成后二次分发、或者接方案一

#### 避免消息丢失

- 消息发送确认
- - RabbitMQ 可以开启发送者confirm模式，所有消息是否发送成功都会通知发送者
- 消息消费ACK
- - 开启RabbitMQ的消息ACK机制，消费处理完成后再ack
- 队列消息持久化
- - 将队列消息持久化到磁盘（会牺牲部分性能）
- - 持久化要慎重使用：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈

#### 消息的重复问题

- 保持幂等性
- - 核心是使用唯一标识，来标记某条消息是否已经处理过。具体方案可选的则有很多，比如：
- - 使用数据库自增主键，或者唯一键来保证数据不会重复变动
- - 使用中间状态，以及状态变动有序性来判断业务是否以已经被处理
- - 利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息
- - 或者消息唯一标识，在Redis等NoSQL中维护一个处理缓存，判断是否已经处理过

#### 消息积压处理

- 增加消费脚本
- - 本地处理的时候，可以考虑使用动态增减消费者数量的方式来预处理防止大量积压
- 临时紧急扩容
- - 消息延时、积压处理、 消费脚本优化
- - 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉
- - 建立临时队列（10倍于当前），然后临时脚本将积压的消息快速导入到临时队列

#### 延迟消息处理
- RabbitMQ的死信队列
- - 死信队列需要配置转发规则，到期消息会转发到另外一个队列中，消费者监听最终接收队列即可
- 延迟消息Exchange插件
- - 该插件可以接收定时转发消息，等到到时见之后，才会将消息正式转发到队列
- - 问题：消息持久化存储在单台机器，并且无管理界面可查询控制，积压消息难以处理
- - 该插件后来支持了消息可查询
- 不支持延迟消息机制的业务方案
- - 将消息持久化到数据库中，后期选择定时任务的方式，查询到期消息送入队列处理
