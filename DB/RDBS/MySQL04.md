分库分表
==

## 14. 分库分表

### 14.1 分库分表瓶颈条件

#### I/O瓶颈
- 第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询会产生大量的IO，降低查询速度->分库和垂直分表
- 第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 ->分库

#### CPU瓶颈
- 第一种：SQL问题：如SQL中包含join,group by, order by，非索引字段条件查询等，增加CPU运算的操作->SQL优化，建立合适的索引，在业务Service层进行业务计算。
- 第二种：单表数据量太大，查询时扫描的行太多，SQl效率低，增加CPU运算的操作。->水平分表。

#### 拆分条件
- 分库分表之前，先尽力做力所能及的优化：升级硬件、升级网络、读写分离、索引优化，归档处理等。当数据量达到单表瓶颈后，在考虑分库分表。
- 能不分就不分
- 数据量过大，正常运维影响业务访问（DDL锁表影响业务的时候）
- 随着业务发展，需要对某些字段垂直拆分
- 数据量快速增长

### 14.2 拆分方式与中间件

#### 分库分表中间件（ Sharding-jdbc Mycat）

#### 拆分方式

- 水平拆分
- - 保持数据表结构不变，通过某种策略存储数据分片
- - 这样每一片数据分散到不同的表或者库中，达到了分布式的目的
- - 水平拆分可以支撑非常大的数据量
- - 但 分片事务难以解决 ，跨界点Join性能较差，逻辑复杂
- 垂直拆分
- - 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数
- - 垂直分区可以简化表的结构，易于维护
- - 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决
- - 垂直分区会让事务变得更加复杂

#### 动态扩容
- 一次性分足库表 32*32=1024
- 倍数增加机器 / 切换路由规则

#### 全局唯一ID生成机制
- 基于单库的自增id
- snowflake算法  时间戳-机房ID-机器ID-增长序列

### 14.3 分库分表后的问题

#### 事务一致性问题
- 分布式事务、最终一致性方案等等

#### 跨节点关联查询join问题解决
- 使用全局表（通用依赖的表每个库都存一份）
- 字段冗余（反范式冗余部分数据）
- 数据组装（代码层面查询组装数据）
- ER分片（将关联数据路由到相同分片存储，适应后续使用）

#### 跨节点分页、排序、函数问题
- 多分片数据统计性能问题（类ES）

#### 拆分迁移方案（扩容与迁移）
- 停机维护
- 双写迁移
