执行计划与查询优化
==

## 15. 权限管理

### 权限表
- MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化
- 这些权限表分别user，db，table_priv，columns_priv和host。

### 表功能
- user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的
- db权限表：记录各个帐号在各个数据库上的操作权限
- table_priv权限表：记录数据表级的操作权限
- columns_priv权限表：记录数据列级的操作权限
- host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响

## 16. 视图功能

### 16.1 视图概念

#### 基本概念
- 所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据
- 但是，视图并不在数据库中以储存的数据值形式存在
- 行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成

#### 优势
- 视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务
- 只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性

### 16.2 视图的特点

#### 基本特点
- 视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系
- 视图是由基本表(实表)产生的表(虚表)
- 视图的建立和删除不影响基本表
- 对视图内容的更新(添加，删除和修改)直接影响基本表
- 当视图来自多个基本表时，不允许添加和删除数据

#### 视图的优点
- 查询简单化: 视图能简化用户的操作
- 数据安全性: 视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护
- 逻辑数据独立性: 视图对重构数据库提供了一定程度的逻辑独立性

#### 视图的缺点

##### 性能问题
- 数据库必须把视图的查询转化成对基本表的查询，
- 如果这个视图是由一个复杂的多表查询所定义，
- 那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间

##### 修改限制
- 当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改
- 事实上，当从视图中插入或者删除时，情况也是这样
- 对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的

##### 有修改限制的视图特征
- 1.有UNIQUE等集合操作符的视图。
- 2.有GROUP BY子句的视图。
- 3.有诸如AVG\SUM\MAX等聚合函数的视图。
- 4.使用DISTINCT关键字的视图。
- 5.连接表的视图（其中有些例外）


## 17. 存储过程、触发器

### 存储过程

#### 存储过程概念
- 存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次
- 如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快

#### 优点
- 存储过程是预编译过的，执行效率高
- 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯
- 安全性高，执行存储过程需要有一定权限的用户
- 存储过程可以重复使用，减少数据库开发人员的工作量

#### 缺点
- 调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点
- 移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。
- 重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）
- 如果在一个程序系统中大量的使用存储过程，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦

### 触发器

#### 触发器概念
- 触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程
- 触发器是指一段代码，当触发某个事件时，自动执行这些代码

#### 使用场景
- 可以通过数据库中的相关表实现级联更改
- 实时监控某张表中的某个字段的更改而需要做出相应的处理
- 例如可以生成某些业务的编号
- 注意不要滥用，否则会造成数据库及应用程序的维护困难

#### MySQL中六种触发器
- Before Insert、After Insert
- Before Update、After Update
- Before Delete、After Delete



## 18. 子查询

### 子查询三种情况

#### 子查询是单行单列的情况
结果集是一个值，父查询使用：=、 <、 > 等运算符

#### 子查询是多行单列的情况
结果集类似于一个数组，父查询使用：in 运算符

#### 子查询是多行多列的情况
结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表


### 子查询in和exists区别

#### 基本原理
- mysql中的in语句是把外表和内表作hash 连接
- 而exists语句是对外表作loop循环，每次loop循环再对内表进行查询

#### 性能分析
- 如果查询的两个表大小相当，那么用in和exists差别不大
- 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in
- not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引
- 而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快



## 19. 执行计划explain

### 执行计划 explain

#### 释意
- MySQL提供了explain命令来查看语句的执行计划
- 对于查询语句，最重要的优化方式就是使用索引
- 而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等

### 执行计划包含的信息

#### id
- 执行计划包含的信息id 有一组数字组成。表示一个查询中各个子查询的执行顺序
- id相同执行顺序由上至下；id不同，id值越大优先级越高，越先被执行
- id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中

#### select_type
- 1、SIMPLE  ：不包含任何子查询或union等查询
- 2、PRIMARY ：包含子查询最外层查询就显示为 PRIMARY
- 3、SUBQUERY ：在select或 where字句中包含的查询
- 4、DERIVED ：from字句中包含的查询
- 5、UNION ：出现在union后的查询语句中
- 6、UNION RESULT ：从UNION中获取结果集，例如上文的第三个例子

#### table
查询的数据表，当从衍生表中查数据的时候会显示X表示对应的执行计划ID

#### partitions
表分区、表创建的时候可以指定通过那个列进行表分区

#### type
-  (非常重要，可以看到有没有走索引) 访问类型
- ALL 扫描全表数据、index 遍历索引、range 索引范围查找
- index_subquery 在子查询中使用 ref
- unique_subquery 在子查询中使用 eq_ref
- ref_or_null 对Null进行索引的优化的 ref
- fulltext 使用全文索引
- ref 使用非唯一索引查找数据
- eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联

#### possible_keys
- 可能使用的索引，注意不一定会使用。
- 查询涉及到的字段上若存在索引，则该索引将被列出来。
- 当该列为 NULL时就要考虑当前的SQL是否需要优化了。

#### key
显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NUL

#### TIPS
查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中

#### key_length
索引长度

#### ref 
表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

#### rows 
返回估算的结果集数目，并不是一个准确的值

#### extra
- Using index 使用覆盖索引
- Using where 使用了用where子句来过滤结果集
- Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化
- Using temporary 使用了临时表


## 20. SQL优化

### 20.1 SQL性能优化目标

#### 推荐
SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好

#### 说明
- consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据
- ref 指的是使用普通的索引（normal index）
- range 对索引进行范围检索
- 反例： explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫

### 20.2 慢查询日志

#### 开启慢查询日志
- 配置项：slow_query_log
- 可以使用show variables like ‘slow_query_log’查看是否开启
- 如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件

#### 设置临界时间
- 配置项：long_query_time
- 查看：show VARIABLES like 'long_query_time'，单位秒
- 设置：set long_query_time=0.5

### 20.3 优化查询过程中数据访问

#### 必要性与确认
- 访问数据太多导致查询性能下降
- 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列
- 确认MySQL服务器是否在分析大量不必要的数据行

#### 避免犯如下SQL语句错误
- 查询不需要的数据。解决办法：使用limit解决
- 多表关联返回全部列。解决办法：指定列名
- 总是返回全部列。解决办法：避免使用SELECT *
- 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存

#### explain分析是否扫描额外记录
- 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果
- 改变数据库和表的结构，修改数据表范式
- 重写SQL语句，让优化器可以以更优的方式执行查询。

### 20.4 优化长难查询语句

#### 必要性
- 一个复杂查询还是多个简单查询
- MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多
- 使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的

#### 切分查询
- 将一个大的查询分为多个小的相同的查询
- 一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销
- 分解关联查询，让缓存的效率更高
- 执行单个查询可以减少锁的竞争
- 在应用层做关联更容易对数据库进行拆分
- 查询效率会有大幅提升
- 较少冗余记录的查询

### 20.5 优化特额定类型查询句

#### 规则
- count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)
- MyISAM中，没有任何where条件的count(*)非常快
- 当有where条件时，MyISAM的count统计不一定比其它引擎快
- 可以使用explain查询近似值，用近似值替代count(*)
- 增加汇总表
- 使用缓存

### 20.6 优化关联查询

#### 优化方式
- 确定ON或者USING子句中是否有索引。
- 确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引

### 20.7 优化子查询

#### 优化方式
- 用关联查询替代
- 优化GROUP BY和DISTINCT， 这两种查询据可以使用索引来优化，是最有效的优化方法
- 关联查询中，使用标识列分组的效率更高
- 如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序
- WITH ROLLUP超级聚合，可以挪到应用程序处理

### 20.8 优化LIMIT分页

#### 必要性
- LIMIT偏移量大的时候，查询效率较低

#### 优化方式
- 可以记录上次查询的最大ID，下次查询时直接根据该ID来查询（ 游标 ）

### 20.8 优化UNION查询

#### 必要性
- 如果使用UNION ALL，不会合并重复的记录行
- UNION ALL的效率高于UNION

### 20.9 优化WHERE子句

#### 优化方法
- 1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
- 2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如
- 3.应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描
- 4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描
- 5.in 和 not in 也要慎用，否则会导致全表扫描
- 6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索
- 7.如果在 where 子句中使用参数，也会导致全表扫描
- 8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描
- 9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描
- 10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引

## 21. 数据库优化

### 为什么要优化

#### 优化原因
- 系统的吞吐量瓶颈往往出现在数据库的访问速度上
- 随着应用程序的运行，数据库中的数据会越来越多，处理时间会相应变慢
- 数据是存放在磁盘上的，读写速度无法和内存相比

#### 优化原则
- 减少系统瓶颈，减少资源占用，增加系统的反应速度。

### 数据库结构优化
####  将字段很多的表分解成多表
- 对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表
- 因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢

#### 增加中间表
- 对于需要经常联合查询的表，可以建立中间表以提高查询效率
- 通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询

#### 增加冗余字段
- 设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅
- 但是，合理地加入冗余字段可以提高查询速度
- 表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差
- 冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题
