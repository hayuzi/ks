Redis数据类型以及其底层结构
==


## 1. 基本数据类型

Redis支持5种对象类型，分别是字符串(string)、列表(list)、哈希(hash)、集合(set)、有序集合(zset)，redisObject使用type字段记录自身属于哪种类型。

而每种对象类型至少使用了两种底层数据结构来实现，redisObject使用编码字段（encoding字段）记录了自己使用的是哪种底层数据结构实现。
而*ptr指针则会直接指向这个对应的底层数据结构。

每个对象会用到的编码以及对应的数据结构详见下表，即共8种底层数据结构：

```
对象                  编码        数据结构
string 字符串对象        int       可以存储long类型的整数
                        embstr    embstr编码的简单动态字符串
                        raw       简单动态字符串（SDS）

list 列表对象           ziplist     压缩列表
                    linkedlist    双端链表

hansh 哈希对象          ziplist     压缩列表
                    hashtable       字典

set 结合对象            intset      整数集合
                    hashtable       字典

zset 有序集合对象        ziplist      压缩列表
                    skiplist       字典加跳表                    

```

> Redis中的键，都是用字符串对象来存储的，即对于Redis数据库中的键值对来说，键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象中的其中一种


### 1.1 string类型
类型介绍：
- String类型是二进制安全的。redis的string可以包含任何数据，比如jpg图片或者序列化的对象。
- string类型是redis的最近本的数据类型，一个键最大能存储512MB

应用场景：
- 信息缓存、计数器、分布式锁等

底层实现：
- 对于整型  使用int实现
- embstr编码的简单动态字符串
- raw编码的简单动态字符串


### 1.2 list类型
类型介绍：
- 列表是简单的字符串列表，按照插入顺序排序。 可以添加一个元素到列表的头部（左边）或者尾部（右边）

应用场景：
- 可以作为队列来使用，业务中也是使用的该功能

底层实现：
- 双端链表（Linkedlist）
- 压缩表（Ziplist）

### 1.3 hash类型
类型介绍：
- Redis Hash 是一个键值对集合。支持一个string类型的field和value的映射表
- 适合存储对象

应用场景：
- 用户购物车、经常变动的对象结构

底层实现：
- 哈希表（Hashtable）
- 压缩表（Ziplist）


### 1.4 set类型
类型介绍：
- string类型的无序集合，数据不重复

应用场景：
- 收藏夹等

底层实现：
- 哈希表（Hashtable）
- 整型集合（intset）


### 1.5 zset类型（sorted set）
类型介绍：
- string类型元素的集合，且不允许重复的成员，且每个元素都会关联一个 double类型的分数

应用场景：
- 实时排行榜

底层实现：
- 压缩表（Ziplist）
- 跳表（skiplist）

### 1.6 Redis Stream
类型介绍：
- Redis 5.0 版本新增加的数据结构，用于消息队列功能
- Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃
- 而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据

应用场景：

底层实现：



## 2. Redis事务

### 2.1 事务机制
#### 执行的流程
- 使用 MULTI 开启一个事务
- 在MULTI和EXEC之间的， 每次操作的命令都会加入到一个队列中，不会即时执行
- 使用EXEC命令提交事务，开始顺序执行队列中的命令
- 如果客户端在使用MULTI开启了事务后，却因为断线而没有成功执行EXEC,那么事务中的所有命令都不会被执行
- **需要特别注意的是**：即使事务中有某条/某些命令执行失败了，事务队列中的其他命令仍然会继续执行，Redis不会停止执行事务中的命令。

#### 其他几个重要命令
- DISCARD
- - 当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空，并且客户端会从事务状态中退出
- WATCH 
- - WATCH可以为Redis事务提供 check-and-set （CAS）行为。被WATCH的键会被监视，并会发觉这些键是否被改动过了。 
- - 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败
- UNWATCH    
- - 取消 WATCH 命令对所有 key 的监视，一般用于DISCARD和EXEC命令之前。
- - 如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。 
- - 因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了

#### 关于事务的原子操作
Redis 官方认为Redis事务是一个原子操作，这是站在执行与否的角度考虑的。

但是从ACID原子性定义来看，严格意义上讲Redis事务是非原子型的，因为在命令顺序执行过程中，一旦发生命令执行错误Redis是不会停止执行然后回滚数据。

### 2.2 事务原子性定义

#### 关系数据库中
- 原子性：一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
- 事务在执行过程中发生错误，会被恢复(Rollback)到事务开始前的状态，就像这个事务从来没有执行过一样。

#### Redis文档事务
- 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断
- 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

### 2.3 为何不支持回滚
- 在事务运行期间虽然Redis命令可能会执行失败，但是Redis依然会执行事务内剩余的命令而不会执行回滚操作
- Redis官方认为 ， 只有当被调用的Redis命令有语法错误时，这条命令才会执行失败；或者对某个键执行不符合其数据类型的操作
- 这些错误很可能在开发期间发现，一般很少在生产环境发生
- 支持事务回滚能力会导致设计复杂，这与Redis的初衷相违背，Redis的设计目标是功能简化及确保更快的运行速度




