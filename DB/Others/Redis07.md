Redis 集群原理
==

## 1. 主从架构

### 1.1 并发承载
- 读高并发--单机承载QPS在上万到几万不等（依赖于机器配置）

### 1.2 redis主从复制机制
- 建议必须开启master-node的持久化
- 不建议slave node作为热备份（宕机重启数据复制可能清空）
- 全量复制RDB / 写命令缓存增量复制 / 断点续传 / 无磁盘化配置 / 心跳 / 异步复制
- slave不会过期key，统一依赖master通知
- 故障转移

### 1.3 主从复制作用

#### 数据冗余
- 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式

#### 故障恢复
- 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余

#### 负载均衡
- 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载；
- 尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量

#### 高可用基石
- 主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础

### 1.4 实现原理

#### 三个阶段
- 连接建立阶段、数据同步阶段、命令传播阶段

#### 连接建立阶段
该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备:

步骤1：保存主节点信息
- slaveof 命令是异步的，在从节点上执行slaveof命令，从节点立即向客户端返回ok，
- 从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息

步骤2：建立socket连接
- 从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接
- 主节点接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端， 后面的步骤会以从节点向主节点发送命令请求的形式来进行。

步骤3：发送ping命令
- 从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求
- 从节点发送ping命令后，可能出现3种情况：
- - 返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续
- - 超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连
- - 返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连

步骤4：身份验证
- 如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。
- 从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值

步骤5：发送从节点端口信息
- 身份验证之后，从节点会向主节点发送其监听的端口号（前述例子中为6380），主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；
- 该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用

#### 数据同步阶段
- 主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。
- 具体执行的方式是：从节点向主节点发送 psync 命令（Redis2.8以前是sync命令），开始同步。
- 数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制

#### 命令传播阶段
- 数据同步阶段完成后，主从节点进入命令传播阶段；
- 在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性
- 命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。
- 数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的 repl-disable-tcp-nodelay 配置等有关。



## 2. 基于哨兵的高可用

### 2.1 哨兵模式必要性
- Redis 的主从复制模式下，一旦主节点由于故障不能提供服务，需要手动将从节点晋升为主节点
- 同时还要通知客户端更新主节点地址，这种故障处理方式从一定程度上是无法接受的
- Redis 2.8 以后提供了 Redis Sentinel 哨兵机制
- Redis Sentinel 是 Redis 高可用的实现方案。Sentinel 是一个管理多个 Redis 实例的工具，它可以实现对 Redis 的监控、通知、自动故障转移。
- 哨兵模式的主要作用在于它能够自动完成故障发现和故障转移，并通知客户端，从而实现高可用

### 2.2 实现方式

#### Sentinel与Redis Node
- Redis Sentinel 是一个特殊的 Redis 节点。在哨兵模式创建时，需要通过配置指定 Sentinel 与 Redis Master Node 之间的关系，
- 然后 Sentinel 会从主节点上获取所有从节点的信息，之后 Sentinel 会定时向主节点和从节点发送 info 命令获取其拓扑结构和状态信息。

#### Sentinel与Sentinel
- 基于 Redis 的订阅发布功能， 每个 Sentinel 节点会向主节点的 sentinel：hello 频道上发送该 Sentinel 节点对于主节点的判断以及当前 Sentinel 节点的信息
- 同时每个 Sentinel 节点也会订阅该频道， 来获取其他 Sentinel 节点的信息以及它们对主节点的判断

#### 心跳机制
- 通过以上两步所有的 Sentinel 节点以及它们与所有的 Redis 节点之间都已经彼此感知到，
- 之后每个 Sentinel 节点会向主节点、从节点、以及其余 Sentinel 节点定时发送 ping 命令作为心跳检测， 来确认这些节点是否可达


### 2.3 故障转移

#### 主观下线
- 每个 Sentinel 都会定时进行心跳检查，当发现主节点出现心跳检测超时的情况时，此时认为该主节点已经不可用，这种判定称为主观下线

#### 客观下线
- 之后该 Sentinel 节点会通过 sentinel ismaster-down-by-addr 命令向其他 Sentinel 节点询问对主节点的判断
- 当 quorum（法定人数） 个 Sentinel 节点都认为该节点故障时，则执行客观下线，即认为该节点已经不可用
- 这里 quorum 的值是我们在哨兵模式搭建时指定的，通常为 Sentinel节点总数/2+1，即半数以上节点做出主观下线判断就可以执行客观下线

#### 哨兵选举
- 因为故障转移的工作只需要一个 Sentinel 节点来完成，所以 Sentinel 节点之间会再做一次选举工作， 基于 Raft 算法选出一个 Sentinel 领导者来进行故障转移的工作。

#### 哨兵领导者故障转移步骤
- 在从节点列表中选出一个节点作为新的主节点
- Sentinel 领导者节点会对选出来的从节点执行 slaveof no one 命令让其成为主节点
- Sentinel 领导者节点会向剩余的从节点发送命令，让他们从新的主节点上复制数据
- Sentinel 领导者会将原来的主节点更新为从节点， 并对其进行监控， 当其恢复后命令它去复制新的主节点

### 2.4 主要功能
- 集群监控: 负责监控redis master和 slave的进程是否正常工作
- 消息通知: 如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员
- 故障转移: 如果mater node挂了，会自动转移到 slave node上
- 配置中心: 如果故障转移发生了，通知client客户端新的master地址

### 2.5 经典三节点哨兵集群
- 哨兵自身通过redis的 pub/sub机制实现哨兵节点的相互通信
- 多哨兵模式、每个都会监控主redis服务器，哨兵之间还会互相监控
- 主观下线与客观下线，修复间隔默认30秒

### 2.6 数据丢失（主从复制异常 / 脑裂）及其解决方案（配置等）

### 2.7 缺点以及与cluster对比
- 哨兵维持主从切换，通常每个主备都存全量数据，不能分布式保存数据
- cluster是为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器
- sentinel着眼于高可用，Cluster提高并发量


## 3. Redis cluster

### 3.1 Redis cluster

#### 简介 
- Redis-Cluster采用无中心结构，每个节点都保存数据，节点之间互相连接从而知道整个集群状态。
- Cluster模式其实就是多个主从复制的结构组合起来的，每一个主从复制结构可以看成一个节点
- 自动分片，每个master放一部分数据，高可用， gossip协议

#### 节点分片
- hash算法、一致性hash算法、Redis Cluster的hash slot算法（CRC16计算hash值）
- 通过哈希方式，将数据分片，每个节点均分存储一定哈希插槽区间的数据，默认分配了 16384个槽位
- 每份数据分片会存储在多个互为主丛的多节点上
- 数据写入先写主节点，再同步到从节点（支持配置为阻塞同步）
- 同一分片多个节点间的数据不保持强一致性
- 读取数据时候当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点
- 扩容时需要把旧节点的数据迁移一部分到新节点

#### 主备切换原理
- 主客观宕机、从节点过滤、从节点选举
- Redis集群是不保证数据一致性的
- Raft算法---集群内选主

### 3.2 优缺点
#### 优点
- 无中心架构，支持动态扩容，对业务透明
- 具备Sentinel的监控和自动Failover（故障转移）能力
- 客户端不需要连接集群的所有节点，连接集群中任何一个可用节点即可
- 高性能，客户端直接连接redis服务，免去了proxy代理的损耗

#### 缺点
- 运维复杂，数据迁移需要人工干预
- 只能使用0号数据库
- 不支持批量操作（pipeline管道操作）
- 分布式逻辑和存储模块耦合等

### 3.3 重点回顾

节点通过握手来将其他节点添加到自己所处的集群当中。

集群中的 16384 个槽可以分别指派给集群中的各个节点， 每个节点都会记录哪些槽指派给了自己， 而哪些槽又被指派给了其他节点。

节点在接到一个命令请求时， 会先检查这个命令请求要处理的键所在的槽是否由自己负责， 如果不是的话， 节点将向客户端返回一个 MOVED 错误， MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点。

对 Redis 集群的重新分片工作是由客户端执行的， 重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。

如果节点 A 正在迁移槽 i 至节点 B ， 那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时， 节点 A 会向客户端返回一个 ASK 错误， 指引客户端到节点 B 继续查找指定的数据库键。

MOVED 错误表示槽的负责权已经从一个节点转移到了另一个节点， 而 ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施。

集群里的从节点用于复制主节点， 并在主节点下线时， 代替主节点继续处理命令请求。

集群中的节点通过发送和接收消息来进行通讯， 常见的消息包括 MEET 、 PING 、 PONG 、 PUBLISH 、 FAIL 五种。
